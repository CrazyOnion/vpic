begin_globals {
  species_t* sp;
};

begin_initialization {


  num_step = 1;                      // Run for one step so we can do output once
  status_interval = 100;             // Basically don't print status
  sync_shared_interval = status_interval;
  clean_div_e_interval = status_interval;
  clean_div_b_interval = status_interval;

  define_units(1, 1);                // speed of light and eps0
  define_timestep( 0.95/sqrt(3.0) ); // This implies dx=dy=dz = 1

  int gnx = 8;
  int gny = 4;
  int gnz = 4;

  int topox = 2;
  int topoy = 1;
  int topoz = 1;

  define_periodic_grid(0,0,0,              // Low corner
                       gnx,gny,gnz,        // High corner
                       gnx,gny,gnz,        // Resolution
                       topox,topoy,topoz); // Topology

  // Space is by default filled with first material defined
  define_material("vacuum",1.0);

  // Create the field array
  define_field_array(NULL, 0.00);

  // Create species
  species_t* sp = define_species("electron",  // name
                                        -1.,  // charge
                                         1.,  // mass
                                          4,  // maximum number of local particles
                                         -1,  // automatic numbner of particle movers
                                          0,  // sort never
                                          1); // sort mode out-of-place
  global->sp = sp;

  // create annotation buffer
#ifdef VPIC_PARTICLE_ANNOTATION
  sp->allocate_annotation_buffer(2);
#else
#warning "No annotation buffer. compile with PARTICLE_ANNOTATE=ON"
#endif

  // Create a second species that will not have IDs or annotations
  species_t* pos = define_species("positrons", 1., 1., sp->max_np, -1, 0, 1);

  // Set field values
  set_region_field(everywhere, 0.,0.,0., 0.,0.,0.); // Should we set random field values so they don't compress too well?

  // Generate particles
  seed_entropy(rank()); // different random numbers on different ranks

  if(rank() == 0) {
    for(int i=0; i<sp->max_np; i++) {
      double x = 3.9;
      double y = 2.1 + 0.01*i;
      double z = 2.2;

      double ux = 0.999; // nearly c
      double uy = 0.;
      double uz = 0.;

      inject_particle(sp,  x,y,z, ux,uy,uz, 1., 0, 0);
      inject_particle(pos, x,y,z, ux,uy,uz, 1., 0, 0);
#ifdef VPIC_PARTICLE_ANNOTATION
      sp->set_annotation(i, 0, (float)i);   // slot 0
      sp->set_annotation(i, 1, (float)i*i); // slot 1
#endif
    }
  }

#ifdef VPIC_GLOBAL_PARTICLE_ID
  // Add global IDs by moving to a tracer species;
  sim_log("Making all eletrons tracers");
  species_t * sp2 = make_tracers_by_percentage(sp, 100.0, Tracertype::Move);
  global->sp = sp2;

  // the make_tracers call reverses the order of particles and THEN gives IDs. This is confusing, so lets hand out IDs manually
  for(int i=0; i<sp2->max_np; i++) {
    sp2->p_id[i] = sp2->max_np-i - 2;
  }
#endif

  sim_log("Done with setup");
  fflush(NULL);
}

# define UNVOXEL(rank, ix, iy, iz, nx, ny, nz) BEGIN_PRIMITIVE { \
  int _ix, _iy, _iz;                                             \
  _ix  = (rank);        /* ix = ix+gpx*( iy+gpy*iz ) */          \
  _iy  = _ix/int(nx);   /* iy = iy+gpy*iz */                     \
  _ix -= _iy*int(nx);   /* ix = ix */                            \
  _iz  = _iy/int(ny);   /* iz = iz */                            \
  _iy -= _iz*int(ny);   /* iy = iy */                            \
  (ix) = _ix;                                                    \
  (iy) = _iy;                                                    \
  (iz) = _iz;                                                    \
} END_PRIMITIVE

begin_diagnostics {

  int ix, iy, iz, rx, ry, rz;

  for(int r=0; r<nproc(); r++) {
    if(r==rank()) {
      for(int i=0; i<global->sp->np; i++) {

        int local_i = global->sp->p[i].i;

        // Calculate local ix/iy/iz
        UNVOXEL(local_i, ix, iy, iz, grid->nx+2, grid->ny+2, grid->nz+2);
        ix--; iy--; iz--; // Account for for first ghost cell

        // Convert ix/iy/iz to global
        float gix = grid->x0 + ix*grid->dx + 0.5*(global->sp->p[i].dx+1.)*grid->dx;
        float giy = grid->y0 + iy*grid->dy + 0.5*(global->sp->p[i].dy+1.)*grid->dy;
        float giz = grid->z0 + iz*grid->dz + 0.5*(global->sp->p[i].dz+1.)*grid->dz;

        printf("<%d> sp->id %d, particle %d: local_i=%d ix=%d global_x=%f global_y=%f", rank(), global->sp->id, i, ix, local_i, gix, giy);
#ifdef VPIC_GLOBAL_PARTICLE_ID
        if(global->sp->has_ids) {
          printf(" id=%d", global->sp->p_id[i]);
        }
#endif
#ifdef VPIC_PARTICLE_ANNOTATION
        if(global->sp->has_annotation) {
          for(int j=0; j<global->sp->has_annotation; j++) {
            printf(" a[%d]=%f", j, global->sp->get_annotation(i,j));
          }
        }
#endif
        printf("\n");
      }
    }
    mp_barrier();
  }
}

#undef UNVOXEL

begin_particle_injection {
}

begin_current_injection {
}

begin_field_injection {
}

begin_particle_collisions {
}


